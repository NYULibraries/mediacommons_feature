<?php

/**
 * @file
 * Module file for mediacommons_filter.
 */
function mediacommons_filter_permission ( ) {
	return array (
	  'administer mediacommons filters' => array(
			'title' => t('Administer allowed external sources widget'),
			'description' => t('Allow external sources in iframes'),
		),
	);
}

/**
 * Implements hook_menu().
 */
function mediacommons_filter_menu ( ) {
  $items = array ();
  $items['admin/people/external-sources'] = array (
    'title' => 'Filter iframe',
    'description' => t('Provides an extended Image Field for displaying.'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mediacommons_filter_admin'),
    'access arguments' => array ( 'administer mediacommons filters' ),
    'file' => 'mediacommons_filter.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_help().
 */
function mediacommons_filter_help($path, $arg) {
  switch ($path) {
    case 'admin/help#mediacommons_filter':
      return t("<p>To use these filters, go to !link and configure an input format, or create a new one.</p>",
         array('!link' => l(t('admin/config/content/formats'), 'admin/config/content/formats'))
      );
  }
}

/**
 * Implements hook_filter_info().
 *
 * Here we define the different filters provided by the module. For this
 * example, time_filter is a very static and simple replacement, but it requires
 * some preparation of the string because of the special html tags < and >. The
 * foo_filter is more complex, including its own settings and inline tips.
 */
function mediacommons_filter_filter_info() {
  $filters['filter_iframe'] = array(
    'title' => t('Limit allowed iframe sources'),
    'description' => t('Remove iframes with unwanted sources.'),
    'default settings' => array( 'filter_iframe' => 'mediacommons.futureofthebook.org', ),
    'process callback' => '_filter_iframe_process',
    'settings callback' => '_filter_iframe_settings',
    'tips callback' => '_filter_iframe_tips',
  );
  return $filters;
}

/**
 * Get the list of allowed domains.
 *
 * @return
 *   An array of domains.
 */
function mediacommons_filter_get_allowed_domains($) {

	$cache = cache_get('domains', 'cache_mediacommons_filter');

	$domains = array();

	if ($cache && ! empty($cache->data)) {
    $domains = $cache->data;
  }
  else {
    $result = db_query("SELECT * FROM {mediacommons_filter} ORDER BY domain");
    while ( $domain = $result->fetchAssoc() ) {
      $domains[] = $domain['domain'] ;
    }
    cache_set('domains', $domains, 'cache_mediacommons_filter' , CACHE_TEMPORARY);
  }
  return $domains;
}

function mediacommons_filter_flush_caches() {
	return array('cache_mediacommons_filter');
}

/**
 * Settings callback for iframe filter.
 *
 * The settings defined in this form are stored in database by the filter
 * module, and they will be available in the $filter argument.
 */
function _filter_iframe_settings($form, $form_state, $filter, $format, $defaults) {
  $settings['filter_iframe'] = array(
    '#type' => 'item',
    '#title' => t('Domains  that are allow to be use in ifames'),
    '#description' => t('Comma separated string of domains  that are allow (whitelisted) to be use with iframes.'),
    '#markup' => t ('Manage !link.', array( '!link' => l( t('allowed domains'), 'admin/people/external-sources') ) ),
  );
  return $settings;
}

/**
 * Foo filter process callback.
 *
 * The actual filtering is performed here. The supplied text should be returned,
 * once any necessary substitutions have taken place. The example just replaces
 * foo with our custom defined string in the settings page.
 */
function _filter_iframe_process ( $text, $filter, $format ) {

	if ( empty ( $text ) ) return ;

  $allowed_domains = mediacommons_filter_get_allowed_domains() ;

  include_once ( libraries_get_path('simplehtmldom') . '/simple_html_dom.php' );

  $dom = str_get_html ( $text ) ;

  if ( is_object  ( $dom ) ) {
    foreach ( $dom->find( 'iframe') as $element ) {
      $parse_url = parse_url ( $element->src ) ;
      if ( isset ( $parse_url['host'] ) && ! in_array ( $parse_url['host'], $allowed_domains, true ) ) {
        $element->src = '';
        $element->class = 'invalid-source';
      }
    }
    $text = (string) $dom ;
  }

  return $text ;

}


/**
 * Filter tips callback for iframe filter.
 */
function _filter_iframe_tips($filter, $format, $long = FALSE) {
  if ( ! $long ) {
    // This string will be shown in the content add/edit form.
    return t('Remove non-allowed iframe sources.');
  }
  else {
    return t ('Remove non-allowed iframe sources. You can add, edit or remove domains in !link.', array( '!link' => l( t('allowed domains'), 'admin/people/external-sources') ) ) ;
  }
}

function mediacommons_filter_form_alter(&$form, &$form_state, $form_id) {
	if (isset($form_state['node'])) {
		$form['actions']['submit']['#validate'][] = 'mediacommons_filter_node_validate_handler';
	}
}

function mediacommons_filter_node_validate_handler ( $form, &$form_state ) {

  if (!isset($form_state['node'])) return TRUE;

  include_once(libraries_get_path('simplehtmldom') . '/simple_html_dom.php');

  $node = $form_state['values'];

  $allowed_domains = mediacommons_filter_get_allowed_domains();

  $fields = field_info_instances('node', $node['type'] );

  foreach ($fields as $key => $field) {
    $field_info_instance = field_info_instance($field['entity_type'], $field['field_name'], $field['bundle']) ;
    if ( $field_info_instance['widget']['module'] === 'text') {
      $this_field = $node[$key];
      foreach ( $this_field[$node['language']] as $value ) {
      	$formats = filter_list_format ( $value['format'] ) ;
        if ( array_key_exists( 'filter_iframe', $formats ) ) {
          $html = str_get_html( $value['value'] ) ;
          if ( empty ( $html ) ) continue;
          // Find all iframe
          foreach ( $html->find('iframe') as $element ) {
          	$parse_url = parse_url( $element->src ) ;
          	if ( isset ( $parse_url['host'] ) && ! in_array ( $parse_url['host'] , $allowed_domains, true ) ) {
          	  form_set_error( $key, t('Found not valid iframe !source', array ( '!source' => $element->src ) ) );
            }
          }
        }
      }
    }
  }

}
