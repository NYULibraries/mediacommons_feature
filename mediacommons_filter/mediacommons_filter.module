<?php

/**
 * @file
 * Module file for mediacommons_filter.
 */

/**
 * Implements hook_menu().
 */
function mediacommons_filter_menu() {

  $access = array('administer mediacommons filters');

  $items = array () ;

  $items['admin/people/external-sources'] = array(
    'title' => 'Filter iframe',
    'description' => t('Provides an extended Image Field for displaying.'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mediacommons_filter_admin'),
    'access arguments' => $access,
    'file' => 'mediacommons_filter.admin.inc',
  );

  return $items;

}

/**
 * Implements hook_help().
 */
function mediacommons_filter_help($path, $arg) {
  switch ($path) {
    case 'admin/help#mediacommons_filter':
      return t("<p>To use these filters, go to !link and configure an input format, or create a new one.</p>",
         array('!link' => l(t('admin/config/content/formats'), 'admin/config/content/formats'))
      );
  }
}

/**
 * Implements hook_filter_info().
 *
 * Here we define the different filters provided by the module. For this
 * example, time_filter is a very static and simple replacement, but it requires
 * some preparation of the string because of the special html tags < and >. The
 * foo_filter is more complex, including its own settings and inline tips.
 */
function mediacommons_filter_filter_info() {
  $filters['filter_iframe'] = array(
    'title' => t('Limit allowed iframe sources'),
    'description' => t('Remove iframes with unwanted sources.'),
    'default settings' => array( 'filter_iframe' => 'mediacommons.futureofthebook.org', ),
    'prepare callback' => '_filter_iframe_prepare',
    'process callback' => '_filter_iframe_process',
    'settings callback' => '_filter_iframe_settings',
    'tips callback' => '_filter_iframe_tips',
  );
  return $filters;
}

/**
 * Get the list of allowed domains.
 *
 * @return
 *   An array of domains.
 */
function mediacommons_filter_get_allowed_domains() {
  if ( $cache = cache_get('domains', 'cache_mediacommons_filter') ) {
    $domains = $cache->data;
  }
  else {
    $domains = array();
    $result = db_query("SELECT * FROM {mediacommons_filter} ORDER BY domain");
    while ( $domain = $result->fetchAssoc() ) {
      $domains[] = $domain['domain'];
    }
    cache_set('domains', $domains, 'cache_mediacommons_filter');
  }
  return $domains;
}

/**
 * Settings callback for iframe filter.
 *
 * The settings defined in this form are stored in database by the filter
 * module, and they will be available in the $filter argument.
 */
function _filter_iframe_settings($form, $form_state, $filter, $format, $defaults) {
  $settings['filter_iframe'] = array(
    '#type' => 'item',
    '#title' => t('Domains  that are allow to be use in ifames'),
    '#description' => t('Comma separated string of domains  that are allow (whitelisted) to be use with iframes.'),
    '#markup' => t ('Manage !link.', array( '!link' => l( t('allowed domains'), 'admin/people/external-sources') ) ),
  );
  return $settings;
}

/**
 * Foo filter process callback.
 *
 * The actual filtering is performed here. The supplied text should be returned,
 * once any necessary substitutions have taken place. The example just replaces
 * foo with our custom defined string in the settings page.
 */
function _filter_iframe_process($text, $filter, $format) {

  $replacement = array();

  return preg_replace('!\[filter-iframe(.*?)\]!', '<iframe data-filter="mediacommons_filter" $\1></iframe>', $text);
}


/**
 * Filter tips callback for iframe filter.
 */
function _filter_iframe_tips($filter, $format, $long = FALSE) {
  $replacement = array();

  if (!$long) {
    // This string will be shown in the content add/edit form.
    return t('<em>ALBERTO ORTIZ FLORES</em> replaced with %replacement.', array('%replacement' => $replacement));
  }
  else {
    return t('Every instance of "ALBERTO ORTIZ FLORES" in the input text will be replaced with a configurable value. You can configure this value and put whatever you want there. The replacement value is "%replacement".', array('%replacement' => $replacement));
  }
}

/**
 * iframe filter prepare callback.
 *
 * We'll use [filter-example-time] as a replacement for the time tag.
 * Note that in a more complicated filter a closing tag may also be
 * required. For more information, see "Temporary placeholders and
 * delimiters" at http://drupal.org/node/209715.
 */
function _filter_iframe_prepare($text, $filter) {
  return preg_replace('!<iframe(.*?)>(.*?)</iframe>!', '[filter-iframe $\1]', $text);
}

function mediacommons_filter_form_alter(&$form, &$form_state, $form_id) {
  $form['actions']['submit']['#validate'][] = 'mediacommons_filter_node_validate_handler';
}

function mediacommons_filter_node_validate_handler( $form, &$form_state ) {

  if ( ! isset ( $form_state['node'] ) ) return TRUE ;

  include_once ( libraries_get_path('simplehtmldom') . '/simple_html_dom.php' );

  $node = $form_state['values'];

  $allowed_domains = mediacommons_filter_get_allowed_domains() ;

  $fields = field_info_instances('node', $node['type'] );

  foreach ( $fields as $key => $field ) {
    $field_info_instance = field_info_instance($field['entity_type'], $field['field_name'], $field['bundle']) ;
    if ( $field_info_instance['widget']['module'] === 'text') {
      $this_field = $node[$key];
      foreach ( $this_field[$node['language']] as $value ) {
        if ( $value['format'] === 'limited_html' ) {
          $html = str_get_html( $value['value'] ) ;
          // Find all iframe
          foreach ( $html->find('iframe') as $element) {
          	$parse_url = parse_url( $element->src ) ;
          	if ( ! in_array( $parse_url['host'], $allowed_domains, true ) ) {
          	  form_set_error( $key, t('Found not valid iframe !source', array ( '!source' => $element->src ) ) );
            }
          }
        }
      }
    }
  }

}
